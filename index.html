<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pro DJ House Playground</title>
<style>
  body { margin:0; background:#111; color:#eee; font-family:sans-serif; }
  #app { display:flex; flex-direction:column; align-items:center; padding:20px; }
  .panel { background:#222; border-radius:12px; padding:20px; margin:10px; width:95%; max-width:1200px; display:flex; flex-wrap:wrap; justify-content:center; }
  .knob-container { display:flex; flex-direction:column; align-items:center; margin:10px; }
  .knob { width:60px; height:60px; border-radius:50%; background:#333; border:4px solid #555; display:flex; align-items:center; justify-content:center; cursor:pointer; position:relative; }
  .knob:after { content:''; position:absolute; width:4px; height:20px; background:#eee; top:10px; left:50%; transform:translateX(-50%) rotate(0deg); transform-origin:bottom center; border-radius:2px; transition: transform 0.1s; }
  .label { margin-top:8px; font-size:14px; }
  .pad { width:60px; height:60px; background:#444; margin:5px; border-radius:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; }
  .pad.active { background:#ff5722; }
  #sequencer { display:flex; flex-wrap:wrap; justify-content:center; margin-top:10px; }
  #visualizer { width:100%; height:100px; background:#111; margin-top:20px; border:1px solid #333; border-radius:8px; }
  button { background:#333; border:none; color:#eee; padding:8px 12px; border-radius:6px; margin:4px; cursor:pointer; }
  button:hover { background:#555; }
  #recordBtn { background:#e53935; }
  #downloadBtn { background:#43a047; }
</style>
</head>
<body>
<div id="app">
  <h1>Pro DJ House Playground</h1>
  <div class="panel" id="controlsPanel">
    <!-- Master Pitch -->
    <div class="knob-container">
      <div class="knob" id="masterPitchKnob"></div>
      <div class="label">Master Pitch</div>
    </div>
    <!-- Voice FX Knobs -->
    <div class="knob-container">
      <div class="knob" id="voicePitchKnob"></div>
      <div class="label">Voice Pitch</div>
    </div>
    <div class="knob-container">
      <div class="knob" id="voiceReverbKnob"></div>
      <div class="label">Reverb</div>
    </div>
    <div class="knob-container">
      <div class="knob" id="voiceDelayKnob"></div>
      <div class="label">Delay</div>
    </div>
    <div class="knob-container">
      <div class="knob" id="voiceDistKnob"></div>
      <div class="label">Distortion</div>
    </div>
    <div style="display:flex; flex-direction:column; align-items:center; margin:10px;">
      <button id="recordBtn">Record Voice</button>
      <button id="downloadBtn">Download FX Voice</button>
    </div>
  </div>
  <!-- Pads for instruments + voice -->
  <div class="panel" id="padPanel"></div>
  <!-- Sequencer -->
  <div class="panel" id="sequencer"></div>
  <!-- Visualizer -->
  <canvas id="visualizer"></canvas>
</div>
<script>
const AudioContext = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioContext();

// Global master gain & pitch
const masterGain = ctx.createGain();
masterGain.gain.value = 0.8;
masterGain.connect(ctx.destination);
let masterPlaybackRate = 1;

// Utility for knobs
function createKnob(el, callback) {
  let isDragging = false;
  let angle = 0;
  el.addEventListener('mousedown', e => { isDragging=true; });
  window.addEventListener('mouseup', e => { isDragging=false; });
  window.addEventListener('mousemove', e => {
    if(!isDragging) return;
    let rect = el.getBoundingClientRect();
    let y = e.clientY - rect.top - rect.height/2;
    let x = e.clientX - rect.left - rect.width/2;
    let a = Math.atan2(y,x) * 180/Math.PI;
    angle = Math.min(135, Math.max(-135,a));
    el.querySelector(':after').style.transform = `translateX(-50%) rotate(${angle}deg)`;
    callback((angle+135)/270);
  });
}

// Voice FX chain
let voiceSource, voiceBuffer, voiceNodes={};
function setupVoiceNodes() {
  const pitchNode = ctx.createGain(); // will simulate pitch via playbackRate
  const reverb = ctx.createConvolver();
  const delay = ctx.createDelay();
  delay.delayTime.value = 0.2;
  const distortion = ctx.createWaveShaper();
  distortion.curve = new Float32Array([0,1]);
  voiceNodes = {pitchNode, reverb, delay, distortion};
  pitchNode.connect(reverb);
  reverb.connect(delay);
  delay.connect(distortion);
  distortion.connect(masterGain);
}
setupVoiceNodes();

// Record voice
let mediaRecorder, recordedChunks=[];
document.getElementById('recordBtn').onclick = async ()=>{
  if(!mediaRecorder || mediaRecorder.state==='inactive'){
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    mediaRecorder = new MediaRecorder(stream);
    recordedChunks=[];
    mediaRecorder.ondataavailable = e=>{ recordedChunks.push(e.data); };
    mediaRecorder.onstop = async ()=>{
      const blob = new Blob(recordedChunks,{type:'audio/webm'});
      const arrayBuffer = await blob.arrayBuffer();
      voiceBuffer = await ctx.decodeAudioData(arrayBuffer);
      playVoiceSample();
    };
    mediaRecorder.start();
    document.getElementById('recordBtn').textContent='Stop Recording';
  } else {
    mediaRecorder.stop();
    document.getElementById('recordBtn').textContent='Record Voice';
  }
};

// Play voice sample in sampler pad
function playVoiceSample(){
  if(!voiceBuffer) return;
  const source = ctx.createBufferSource();
  source.buffer = voiceBuffer;
  source.playbackRate.value = voiceNodes.pitchNode.playbackRate || 1;
  source.connect(voiceNodes.pitchNode);
  source.start();
  // add to pads
  const pad = document.createElement('div');
  pad.className='pad active';
  pad.textContent='Voice';
  pad.onclick = ()=>{ playVoiceSample(); };
  document.getElementById('padPanel').appendChild(pad);
}

// Download FX-applied snippet (simplified as original buffer due to Web Audio offline complexity)
document.getElementById('downloadBtn').onclick = ()=>{
  if(!voiceBuffer) return;
  const offlineCtx = new OfflineAudioContext(1, voiceBuffer.length, ctx.sampleRate);
  const source = offlineCtx.createBufferSource();
  source.buffer = voiceBuffer;
  source.playbackRate.value = voiceNodes.pitchNode.playbackRate || 1;
  source.connect(offlineCtx.destination);
  source.start();
  offlineCtx.startRendering().then(renderedBuffer=>{
    const wav = audioBufferToWav(renderedBuffer);
    const blob = new Blob([new DataView(wav)], {type:'audio/wav'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href=url; a.download='voice_fx.wav'; a.click();
  });
};

// Simple WAV encoder
function audioBufferToWav(buffer) {
  let numOfChan = buffer.numberOfChannels,
      length = buffer.length * numOfChan * 2 + 44,
      bufferArray = new ArrayBuffer(length),
      view = new DataView(bufferArray),
      channels = [], i, sample,
      offset = 0, pos = 0;

  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8);
  setUint32(0x45564157); // "WAVE"
  setUint32(0x20746d66); // "fmt " chunk
  setUint32(16); // length
  setUint16(1); // PCM
  setUint16(numOfChan);
  setUint32(buffer.sampleRate);
  setUint32(buffer.sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2);
  setUint16(16); // bits/sample
  setUint32(0x61746164); // "data"
  setUint32(length - pos - 4);

  for(i=0;i<numOfChan;i++) channels.push(buffer.getChannelData(i));
  while(pos<length){
    for(i=0;i<numOfChan;i++){
      sample = Math.max(-1,Math.min(1,channels[i][offset]));
      sample = (0.5 + sample*0.5) * 65535;
      view.setUint16(pos,sample,true);
      pos+=2;
    }
    offset++;
  }
  return bufferArray;

  function setUint16(data){ view.setUint16(pos,data,true); pos+=2; }
  function setUint32(data){ view.setUint32(pos,data,true); pos+=4; }
}

// Create knobs
createKnob(document.getElementById('masterPitchKnob'), v=>{ masterPlaybackRate = 0.5 + v*1.5; });
createKnob(document.getElementById('voicePitchKnob'), v=>{ voiceNodes.pitchNode.playbackRate = 0.5 + v*1.5; });
createKnob(document.getElementById('voiceReverbKnob'), v=>{ /* connect reverb wet/dry if implemented */ });
createKnob(document.getElementById('voiceDelayKnob'), v=>{ voiceNodes.delay.delayTime.value = v*1; });
createKnob(document.getElementById('voiceDistKnob'), v=>{ voiceNodes.distortion.curve = new Float32Array([0,v,1]); });

// Simple visualizer
const canvas=document.getElementById('visualizer');
const ctxVis=canvas.getContext('2d');
canvas.width = canvas.clientWidth;
canvas.height = canvas.clientHeight;
const analyser = ctx.createAnalyser();
masterGain.connect(analyser);
const dataArray = new Uint8Array(analyser.frequencyBinCount);
function draw() {
  requestAnimationFrame(draw);
  analyser.getByteFrequencyData(dataArray);
  ctxVis.fillStyle='#111';
  ctxVis.fillRect(0,0,canvas.width,canvas.height);
  let barWidth = canvas.width / dataArray.length;
  let x=0;
  for(let i=0;i<dataArray.length;i++){
    let barHeight = dataArray[i]/2;
    ctxVis.fillStyle=`rgb(${barHeight+50},50,200)`;
    ctxVis.fillRect(x,canvas.height-barHeight,barWidth,barHeight);
    x+=barWidth+1;
  }
}
draw();
</script>
</body>
</html>
